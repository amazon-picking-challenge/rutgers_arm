/* @file queue_manager.cpp
**
 *
 * @copyright Software License Agreement (BSD License)
 * Copyright (c) 2013, Rutgers the State University of New Jersey, New Brunswick
 * All Rights Reserved.
 * For a full description see the file named LICENSE.
 *
 * Authors: Andrew Dobson, Andrew Kimmel, Athanasios Krontiris, Zakary Littlefield, Kostas Bekris
 *
 * Email: pracsys@googlegroups.com
 */

#include "simulation/structures/queue_manager.hpp"

namespace prx
{
    using namespace util;

    namespace packages
    {
        namespace crowd
        {
            
			deque<queue_managers_t*> queue_manager_container;

			queue_managers_t::queue_managers_t()
			{
				queueing_type=1;
				dlineangle=20;
				//sunit=1.25; //mt - Distance between walls
				//sunit=1.75;
				sunit = 1;
				scale= 1.75;
				qm_name="default";
				qm_id=queue_manager_container.size()+1;

				queue_manager_container.push_back(this);
			}
			/*
			void queue_managers_t::set_queue_manager(int argc,double vals)se
			{
				switch(argc)
				{
				case 1:queueing_type=int(vals);return;
				case 2:dlineangle=vals;return;
				case 3:sunit=vals;return;
				case 4:scale=vals;return;
			//	case 5:char buffer[1000];sprintf(buffer,"%f",vals);qm_name=buffer;return;
				default: return;

				}

				return;
			}
			*/
						
			

			void queue_managers_t::update_buffer()
			{

				// //bufferwalls.clear();
				// //bufferqueues.clear();
				// //bufferwallid.clear();
				// //bufferqueueid.clear();
				// pair<int,int> id;
				// //get_environment_from_triangle(-1,current_operate_queue,3);


				// for(int i=0;i<bufferwalls.size();i++)
				// {
				// 	id.first=int(i/2);
				// 	id.second=i%2;
				// 	bufferwallid.push_back(id);
				// }

				// for(int i=0;i<bufferqueues.size();i++)
				// {
				// 	id.first=int(i/2);
				// 	id.second=i%2;
				// 	bufferqueueid.push_back(id);
				// }


				return;
			}
						
			_2numnpt queue_managers_t::check_conflict(segment_t* seg1) //val1:conflict flag(0-none 1-wall,2-queue) val2:conflict_sequence_in_container pt:conflict point
			{
				// // cout<<"..................."<<endl<<endl<<endl<<"check conflict"<<endl<<endl;
				// cout<<"check conflict"<<endl;
				//seg->startpoint=last point in queue
				//seg->endpoint=try point(generated by offsetrandpt)
				segment_t* seg=new segment_t;
				// // cout<<"try seg:"<<endl;
				// // cout<<seg1->startpt.x<<","<<seg1->startpt.y<<","<<seg1->endpt.x<<","<<seg1->endpt.y<<endl;
				seg->startpt.x=seg1->startpt.x+0.001*(seg1->endpt.x-seg1->startpt.x);
				seg->startpt.y=seg1->startpt.y+0.001*(seg1->endpt.y-seg1->startpt.y);
				seg->endpt=seg1->endpt;
				seg->cal_para();
				_2numnpt ret;
				//update_buffer(); //!!!

				int wall_conflict_seq=-1;
				int queue_conflict_seq=-1;
				wall_conflict_container.clear();
				queue_conflict_container.clear();
				wall_conflict_id.clear();
				queue_conflict_id.clear();
				double wall_conflict_dist=9999;
				double queue_conflict_dist=9999;
				

				points_t conflict_pt;

				segment_t* bufferseg;
				pair<int,int> id;

				for (int i=0;i<wall_segment_structures_container.size();i++)
				{
					//bufferwalls[i]->cal_para();
					bufferseg=wall_segment_structures_container[i]->buffer_segment_left;
					bufferseg->cal_para();
					

					//if(check_seg_intersec(seg,bufferwalls[i]).vals>0)
					if(check_seg_intersec(seg,bufferseg).vals==1 && bufferseg->get_length() >= 0.5)
					{
				
						wall_conflict_seq=i*10000+1;
						bufferseg->seg_key=wall_segment_structures_container[i]->get_hash_key()+1000;
						wall_conflict_container.push_back(bufferseg);
						id.first=i;
						id.second=1;
						wall_conflict_id.push_back(id);
					}

					bufferseg=wall_segment_structures_container[i]->buffer_segment_right;
					bufferseg->cal_para();
					if(check_seg_intersec(seg,bufferseg).vals==1 && bufferseg->get_length() >= 0.5)
					{
				
						wall_conflict_seq=i*10000+2;
						bufferseg->seg_key=wall_segment_structures_container[i]->get_hash_key()+2000;
						wall_conflict_container.push_back(bufferseg);
						id.first=i;
						id.second=2;
						wall_conflict_id.push_back(id);
					}
				}
				util::hash_t<int, std::vector<segment_struct_t*> >::iterator queue_seg_it;
				queue_seg_it=queue_segment_structures_container.begin();
				while(queue_seg_it!=queue_segment_structures_container.end())
				{
					int i=0;
					foreach(segment_struct_t* segment_structure, queue_seg_it->second)
					{

						//bufferqueues[i]->cal_para();
						bufferseg=segment_structure->buffer_segment_left;
						bufferseg->cal_para();

						if(check_seg_intersec(seg,bufferseg).vals==1)//>0)
						{
				
							queue_conflict_seq=segment_structure->get_hash_key()+1000;
							bufferseg->seg_key=queue_conflict_seq;

							queue_conflict_container.push_back(bufferseg);
							id.first=queue_seg_it->first;
							id.second=i;
							queue_conflict_id.push_back(id);
						}

						bufferseg=segment_structure->buffer_segment_right;
						bufferseg->cal_para();
						if(check_seg_intersec(seg,bufferseg).vals==1)//>0)
						{
				
							queue_conflict_seq=segment_structure->get_hash_key()+2000;
							bufferseg->seg_key=segment_structure->get_hash_key()+2000;
							queue_conflict_container.push_back(bufferseg);
							id.first=queue_seg_it->first;
							id.second=i;
							queue_conflict_id.push_back(id);
						}
						i++;
					}

					queue_seg_it++;
				}

				
				

				if(wall_conflict_seq==-1 && queue_conflict_seq==-1)
				{
					ret.pt=seg->endpt;
					ret.val1=0;
					ret.val2=-1;
					if(seg!=NULL)
					{
						delete seg;
						seg=NULL;	
					}
					// cout<<"no conflict"<<endl;
					// cout<<"size:"<<wall_segment_structures_container.size()<<","<<queue_segment_structures_container.size()<<endl;
					return ret;
				}

								


				int flag;
				if (wall_conflict_seq>=0 && !wall_conflict_container.empty() && queue_conflict_seq==-1)
				{
					flag=1;
					for (int i=0;i<wall_conflict_container.size();i++)
					{
						conflict_pt=check_seg_intersec(seg,wall_conflict_container[i]).pt;

						//if(pt_seg_dist(seg->startpt,wall_conflict_container[i])<wall_conflict_dist)
						if(pt_pt_dist(seg->startpt,conflict_pt)<=wall_conflict_dist)
						{
							wall_conflict_dist=pt_seg_dist(seg->startpt,wall_conflict_container[i]);
							wall_conflict_seq=i;
						}
					}   //now, the conflict wall is wall_conflict_container[wall_conflict_seq]
					
				}
				else if (queue_conflict_seq>=0 && !queue_conflict_container.empty() && wall_conflict_seq==-1)
				{
					flag=2;
					for (int i=0;i<queue_conflict_container.size();i++)
					{
						conflict_pt=check_seg_intersec(seg,queue_conflict_container[i]).pt;
						//if(pt_seg_dist(seg->startpt,queue_conflict_container[i])<queue_conflict_dist)
						if(pt_pt_dist(seg->startpt,conflict_pt)<=queue_conflict_dist)
						{
							queue_conflict_dist=pt_seg_dist(seg->startpt,queue_conflict_container[i]);
							queue_conflict_seq=i;
						}
					}   //now, the conflict queue is queue_conflict_container[queue_conflict_seq]
					
				}
				else if (wall_conflict_seq>=0 && !wall_conflict_container.empty() && queue_conflict_seq>=0 && !queue_conflict_container.empty())
				{
					for (int i=0;i<wall_conflict_container.size();i++)
					{
						conflict_pt=check_seg_intersec(seg,wall_conflict_container[i]).pt;

						//if(pt_seg_dist(seg->startpt,wall_conflict_container[i])<wall_conflict_dist)
						if(pt_pt_dist(seg->startpt,conflict_pt)<=wall_conflict_dist)
						{
							wall_conflict_dist=pt_seg_dist(seg->startpt,wall_conflict_container[i]);
							wall_conflict_seq=i;
						}
					}   //now, the conflict wall is wall_conflict_container[wall_conflict_seq]

					for (int i=0;i<queue_conflict_container.size();i++)
					{
						conflict_pt=check_seg_intersec(seg,queue_conflict_container[i]).pt;
						//if(pt_seg_dist(seg->startpt,queue_conflict_container[i])<queue_conflict_dist)
						if(pt_pt_dist(seg->startpt,conflict_pt)<=queue_conflict_dist)
						{
							queue_conflict_dist=pt_seg_dist(seg->startpt,queue_conflict_container[i]);
							queue_conflict_seq=i;
						}
					}   //now, the conflict queue is queue_conflict_container[queue_conflict_seq]

					if(wall_conflict_dist<queue_conflict_dist)
						flag=1;
					else
						flag=2;


				}
				else
				{
					
				
					ret.pt=seg->endpt;
					ret.val1=-1;
					ret.val2=-1;
					if(seg!=NULL)
					{
						delete seg;
						seg=NULL;
					}
					
					return ret;
				}

				

				ret.val1=flag;
				if(flag==1)
				{

					// cout<<"conflict with a wall:"<<endl;
					// cout<<"w con seq:"<<wall_conflict_seq<<endl;
					// cout<<"conflict wall points:"<<wall_conflict_container[wall_conflict_seq]->startpt.x<<","<<wall_conflict_container[wall_conflict_seq]->startpt.y<<","<<wall_conflict_container[wall_conflict_seq]->endpt.x<<","<<wall_conflict_container[wall_conflict_seq]->endpt.y<<endl;
					// cout<<"seg points:"<<seg->startpt.x<<","<<seg->startpt.y<<","<<seg->endpt.x<<","<<seg->endpt.y<<endl;
					// cout<<check_seg_intersec(seg,wall_conflict_container[wall_conflict_seq]).vals<<","<<check_seg_intersec(seg,wall_conflict_container[wall_conflict_seq]).pt.x<<","<<check_seg_intersec(seg,wall_conflict_container[wall_conflict_seq]).pt.y<<endl;

					ret.val2=wall_conflict_seq;
					ret.pt=check_seg_intersec(seg,wall_conflict_container[wall_conflict_seq]).pt;
					if(abs(pt_seg_dist(seg->startpt,wall_conflict_container[wall_conflict_seq]))<1e-6)
					{
						ret.val1=0; //correction 1,confict with the self bufferline
					}
					


					segment_t* real_w;
					real_w=wall_segment_structures_container[wall_conflict_id[wall_conflict_seq].first]->actual_segment;
					//real_w=wall_container_temp[wall_conflict_id[wall_conflict_seq].first].getwall();
					//real_w=wall_container_temp[wall_conflict_id[wall_conflict_seq].first];
					real_w->cal_para();

					if(pt_seg_dist(seg->startpt,real_w)<pt_seg_dist(seg->endpt,real_w))
					{
						ret.val1=0; //correction 2,conflict a buffer line, but leave away from the real wall/queue
					}
					
				}
				else
				{

					// cout<<"conflict with a queue:"<<endl;
					// cout<<"q con seq:"<<queue_conflict_seq<<endl;
					// cout<<"conflict seg points:"<<queue_conflict_container[queue_conflict_seq]->startpt.x<<","<<queue_conflict_container[queue_conflict_seq]->startpt.y<<","<<queue_conflict_container[queue_conflict_seq]->endpt.x<<","<<queue_conflict_container[queue_conflict_seq]->endpt.y<<endl;
					// cout<<"seg points:"<<seg->startpt.x<<","<<seg->startpt.y<<","<<seg->endpt.x<<","<<seg->endpt.y<<endl;
					// cout<<check_seg_intersec(seg,queue_conflict_container[queue_conflict_seq]).vals<<","<<check_seg_intersec(seg,queue_conflict_container[queue_conflict_seq]).pt.x<<","<<check_seg_intersec(seg,queue_conflict_container[queue_conflict_seq]).pt.y<<endl;


					ret.val2=queue_conflict_seq;
					ret.pt=check_seg_intersec(seg,queue_conflict_container[queue_conflict_seq]).pt;

					//below:correction the wrong conflict
					if(abs(pt_seg_dist(seg->startpt,queue_conflict_container[queue_conflict_seq]))<1e-6)
					{
						
						ret.val1=0;
					}

					segment_t* real_q;
					util::hash_t<int, std::vector<segment_struct_t*> >::iterator it;
					it=queue_segment_structures_container.find(queue_conflict_id[queue_conflict_seq].first);

					if(it!=queue_segment_structures_container.end())
					{
						if(queue_conflict_id[queue_conflict_seq].second<it->second.size())
						{
							real_q=it->second[queue_conflict_id[queue_conflict_seq].second]->actual_segment;
							real_q->cal_para();
							if(pt_seg_dist(seg->startpt,real_q)<pt_seg_dist(seg->endpt,real_q))
							{
								ret.val1=0;
								////// cout<<"$$$$$$$$$$$this correction 2,"<<simulation_timestamp<<","<<queue_conflict_id[queue_conflict_seq].first<<","<<queue_conflict_id[queue_conflict_seq].second<<endl; //leaving a real queue
							}		
						}
						else
						{
							ret.val1=0;
						}
					}
					else
					{
						ret.val1=0;

						////// // cout<<"$$$$$$$$$$$this correction 2,"<<simulation_timestamp<<","<<queue_conflict_id[queue_conflict_seq].first<<","<<queue_conflict_id[queue_conflict_seq].second<<endl; //leaving a real queue
					}			


					//real_q=queue_segment_structures_container[queue_conflict_id[queue_conflict_seq].first]->second[queue_conflict_id[queue_conflict_seq].second]->actual_segment;
					//real_q->startpt=queue_container[queue_conflict_id[queue_conflict_seq].first]->breakpts[queue_conflict_id[queue_conflict_seq].second].pt;
					//real_q=queue_segs_obtained[queue_conflict_id[queue_conflict_seq].first];
					
					// real_q->cal_para();
					// if(pt_seg_dist(seg->startpt,real_q)<pt_seg_dist(seg->endpt,real_q))
					// {
					// 	ret.val1=0;
					// 	////// cout<<"$$$$$$$$$$$this correction 2,"<<simulation_timestamp<<","<<queue_conflict_id[queue_conflict_seq].first<<","<<queue_conflict_id[queue_conflict_seq].second<<endl; //leaving a real queue
					// }		
					
					
				}
				
				if(seg!=NULL)
				{
					delete seg;
					seg=NULL;
				}
				
				return ret;
			}


			
			points_t queue_managers_t::get_aligned(points_t refpt, points_t reftopt, segment_t* seg, bool acute_angle) //refpt is the last point of a queue, reftopt is the conflict point with a segment_t. seg is the conflicted segment_t. acute_angle==true means acute turn
			{
				points_t direc;

				double theta1,theta2;
				theta1=cart2pol(reftopt.x-refpt.x,reftopt.y-refpt.y,0)[0];
				theta2=cart2pol(seg->startpt.x-reftopt.x,seg->startpt.y-reftopt.y,0)[0];
				
				if(acute_angle==true)
				{
					if(abs(theta1-theta2)<0.51*PI)
					{
					
						direc=seg->startpt;
						//	PRX_PRINT("thetavalue_____1-", PRX_TEXT_LIGHTGRAY);
									
					}
					else
					{
						direc=seg->endpt;
						//PRX_PRINT("thetavalue________2-", PRX_TEXT_LIGHTGRAY);
					}
				}
				else
				{
					if(abs(theta1-theta2)<0.51*PI)
					{
					
						direc=seg->endpt;
												
						//PRX_PRINT("thetavalue___3", PRX_TEXT_LIGHTGRAY);
									
					}
					else
					{
						direc=seg->startpt;
						//PRX_PRINT("thetavalue__________4-", PRX_TEXT_LIGHTGRAY);					
					}
				}
				return direc;
			}

			// To create new(open) slots if they are not enough
			void queue_managers_t::create_new_slots(queue_t* rq_queue)
			{

				if(rq_queue->get_available_slot_index() >= (rq_queue->triangle_slots.size() - 2))
				{
					generate_slots(rq_queue,1);
					//PRX_PRINT("GENERATING NEW SLOT triangle_slots_size:"<<rq_queue->triangle_slots.size()<<" available_slot_index:"<<rq_queue->get_available_slot_index(),PRX_TEXT_LIGHTGRAY);
					//TODO [Sean]: here put the code for reforming the queue and generate a new slot.
				}
			}


			int queue_managers_t::generate_slots(queue_t* rq_queue,int slot_number) 
			{

				current_operate_queue=rq_queue;

				if (rq_queue->if_trapped == true)
				{
					//PRX_PRINT("trapped", PRX_TEXT_LIGHTGRAY);	
					return -1;
				}

				_numnpt destination,try_point;
				destination.pt=rq_queue->get_last_slot_pt();
				destination.vals = -9999;
				try_point = destination; 


				int rq_queue_id;
				rq_queue_id=rq_queue->queue_id;
				double ssunit;
				ssunit=sunit*scale; // distance between two agents
				int seg_key=-1;
				bool to_follow_wall=false;

				
				get_environment_from_triangle_structure(-1,rq_queue,3);
				//update_buffer();

				if(rq_queue->fluctuation_angle!=-1)
					dlineangle=rq_queue->fluctuation_angle;
				else
					dlineangle=20;

				_queue_info q_info;
				q_info=rq_queue->get_queue_info();

				points_t last_point,lp;
				points_t last_bkpt;
				last_bkpt.set(-9999,-9999,-9999);
				
				
				last_point = q_info.last_slot;
				
				if(rq_queue->breakpts.empty())
				{
					last_bkpt=last_point;
				}
				else
				{
					last_bkpt= rq_queue->breakpts.back().pt;
				}
				segment_t* sg=new segment_t;
				sg->startpt=last_bkpt;sg->endpt=q_info.latest_direction;
				lp=pt_seg_intersec_pt(last_point,sg);
				last_point=lp;
				if(sg!=NULL)
				{
					delete sg;
					sg=NULL;
				}
				
				if(rq_queue->queue_point_slots.empty())// && rq_queue->agents_loc.empty())  //first slot generation //should only run this section once in each queue
				{
					try_point.vals = 0;
					try_point.pt = last_point;

					double dist = 999;
					segment_t* wallseg;

					//problem here: no any slot, so cannot get environment walls
					//ask Aditya when can I get a triangle, and then check this step
					//I wrote codes above (get environment) to get the environment wall
					//However, ask Adittya whether it will work or not
					for (int i = 0;i<wall_segment_structures_container.size();i++)
					{
						// wallseg->startpt = wall_container_temp[i]->startpt;
						// wallseg->endpt = wall_container_temp[i]->endpt;
						wallseg=wall_segment_structures_container[i]->actual_segment;
						wallseg->cal_para();
						dist = pt_seg_dist(try_point.pt, wallseg);
						if (dist<sunit)
						{
							points_t intersec_pt = pt_seg_intersec_pt(try_point.pt, wallseg);

							if (judge_bt_points(intersec_pt, wallseg->startpt, wallseg->endpt) == 2)
							{
								try_point.pt = intersec_pt;
							}
						}
					}
					
					destination = try_point;
					rq_queue->add_new_slot(destination);
					rq_queue->breakpts.front().pt = destination.pt;
					if (slot_number != 2)
					{
						return 1;
					}
					else
					{
						return 2;//todo to do:add more slots
					}
				} //first slot in a queue
				
				try_point = offsetptrand(last_point, q_info.latest_direction, ssunit, dlineangle);
				//try_point.pt.z=last_point.z;
				segment_t* seg=new segment_t;
				seg->startpt = last_point;
				seg->endpt = try_point.pt;
				seg->cal_para();
  				_numnpt breakpt;
				int flag;
				flag = 0;

				//below:first turn
				if (rq_queue->reach_first_turn == false)
				{
					if (q_info.queue_length >= rq_queue->first_turn_dist)
					{
						flag = 4;
					}

					if (flag == 4)//
					{
						points_t ft_direc_pt;
						vector<double> vec;
						vec = pol2cart(rq_queue->first_turn_angle / (2 * PI), 500);
						vec[0] = vec[0] + last_point.x;
						vec[1] = vec[1] + last_point.y;

						//ft_direc_pt.set(vec[0],vec[1],0);Sean
						ft_direc_pt.set(vec[0],vec[1],last_point.z); 
						rq_queue->first_turn_direction = ft_direc_pt;

						try_point = offsetptrand(last_point, rq_queue->first_turn_direction, ssunit, 0);
						seg->endpt = try_point.pt;
						seg->cal_para();
						rq_queue->reach_first_turn = true;

						_numnpt firstturnbk;
						firstturnbk.vals = rq_queue->agents_in_queue.size()+rq_queue->queue_point_slots.size();
						firstturnbk.pt = last_point;
						rq_queue->add_breakpts(firstturnbk);
						rq_queue->direction_list.push_back(rq_queue->direction);
						rq_queue->direction = rq_queue->first_turn_direction;
					}
				}
				
				//PRX_PRINT("Queue manager generate_slots 12 #", PRX_TEXT_LIGHTGRAY);
				//above
				_2numnpt check_conflict_result = check_conflict(seg);
				flag = check_conflict_result.val1;

				//below:reach direction point
				if (flag == 0)
				{
					if (judge_bt_points(pt_seg_intersec_pt(rq_queue->get_direction(), seg), seg->startpt, seg->endpt) != 0)
						flag = 3;

				}
				//above
				int iterate_time = 0;

				if (flag == 0)  //no conflict
				{
					rq_queue->add_new_slot(try_point);
					destination = try_point;
					if(seg!=NULL)
					{
						delete seg;
						seg=NULL;
					}
					
					if (slot_number != 2)
					{
						return 1;
					}

					else
					{
						return 2;
					}

				}
				else if (flag == 1 || flag == 2 || flag == 3)
				{
					points_t align_direc;
					int turn_angle = 0; //small angle turn
					while (flag == 1 || flag == 2 || flag == 3)
					{
						if (iterate_time == 2)
						{
							rq_queue->if_trapped = true;
							if (seg!=NULL)
							{
								delete seg;
								seg=NULL;
							}
							
							return -1;
							//todo: queue re-gen
						}

						if (flag == 1)//nearest conflicted obj is a wall
						{

							_numnpt conflict_pt;
							//points_t align_direc;
							align_direc = q_info.latest_direction;
							conflict_pt = check_seg_intersec(seg, wall_conflict_container[check_conflict_result.val2]);

							if (turn_angle == 0)
							{
								//PRX_PRINT("gs 3", PRX_TEXT_LIGHTGRAY);
								align_direc = get_aligned(seg->startpt, conflict_pt.pt, wall_conflict_container[check_conflict_result.val2], true);
								seg_key=wall_conflict_container[check_conflict_result.val2]->seg_key;
								to_follow_wall=true;
							}
							else
							{
								//PRX_PRINT("gs 4", PRX_TEXT_LIGHTGRAY);
								align_direc = get_aligned(seg->startpt, conflict_pt.pt, wall_conflict_container[check_conflict_result.val2], false);
								seg_key=wall_conflict_container[check_conflict_result.val2]->seg_key;
								to_follow_wall=true;
							}
							breakpt.vals = rq_queue->queue_point_slots.size();
							breakpt.pt = conflict_pt.pt;
							//rq_queue->update_direction(breakpt.pt, align_direc, 1);
							double new_oset;
							new_oset = ssunit - pt_pt_dist(q_info.last_slot, breakpt.pt);
							destination = offsetptrand(breakpt.pt, align_direc, new_oset, 0);

							segment_t* test_seg=new segment_t;
							test_seg->set(conflict_pt.pt,destination.pt);
							if (judge_bt_points(pt_seg_intersec_pt(align_direc, test_seg), test_seg->startpt, test_seg->endpt) != 0) //avoid this situation:after turning, the new destination point beyond an end point of the aligned wall
							{
								align_direc=extend_direction(conflict_pt.pt,destination.pt,1+0.15*ssunit/test_seg->get_length());
							}


							if(test_seg!=NULL)
							{
								delete test_seg;
								test_seg=NULL;
							}
							
							// cout<<"conflict point:"<<endl;
							// cout<<conflict_pt.pt.x<<","<<conflict_pt.pt.y<<endl;


							// cout<<"aligned result:"<<endl;
							// cout<<align_direc.x<<","<<align_direc.y<<endl;


							// cout<<"try_point"<<endl;
							// cout<<destination.pt.x<<","<<destination.pt.y<<endl;
							// cout<<offsetptrand(conflict_pt.pt, align_direc, new_oset, 0).pt.x<<","<<offsetptrand(conflict_pt.pt, align_direc, new_oset, 0).pt.y<<endl;



							//// cout<<"aligned to bufferwall:"<<endl;			
							//// cout<<wall_conflict_container[check_conflict_result.val2]->get_hash_key()<<endl;
							//// cout<<wall_conflict_container[check_conflict_result.val2].startpt.x<<","<<wall_conflict_container[check_conflict_result.val2].startpt.y<<",";
							//// cout<<wall_conflict_container[check_conflict_result.val2].endpt.x<<","<<wall_conflict_container[check_conflict_result.val2].endpt.y<<endl;
							//// cout<<"realwall:"<<endl;
							// for(int l=0;l<wall_container_temp.size();l++)
							// {
							// 	if(wall_container_temp[l]->get_hash_key()!=wall_conflict_container[check_conflict_result.val2]->get_hash_key())
							// 	{
							// 		continue;
							// 	}
							// 	//// cout<<wall_container_temp[l]->get_hash_key()<<endl;
							// 	//// cout<<wall_container_temp[l]->startpt.x<<","<<wall_container_temp[l]->startpt.y<<",";
							// 	//// cout<<wall_container_temp[l]->endpt.x<<","<<wall_container_temp[l]->endpt.y<<endl;
							// 	break;
							// }

								
						}
						else if (flag == 2)
						{
							//PRX_PRINT("gs 5", PRX_TEXT_LIGHTGRAY);
							_numnpt conflict_pt;
							//points_t align_direc;
							align_direc = q_info.latest_direction;
							conflict_pt = check_seg_intersec(seg, queue_conflict_container[check_conflict_result.val2]);


							align_direc=queue_conflict_container[check_conflict_result.val2]->endpt;
							seg_key=queue_conflict_container[check_conflict_result.val2]->seg_key;
							if (turn_angle == 0)
							{
								//PRX_PRINT("gs 6", PRX_TEXT_LIGHTGRAY);
								align_direc = get_aligned(seg->startpt, conflict_pt.pt, queue_conflict_container[check_conflict_result.val2], true);
								seg_key=queue_conflict_container[check_conflict_result.val2]->get_hash_key();
								to_follow_wall=false;
							}
							else
							{
								//PRX_PRINT("gs 7", PRX_TEXT_LIGHTGRAY);
								align_direc = get_aligned(seg->startpt, conflict_pt.pt, queue_conflict_container[check_conflict_result.val2], false);
								seg_key=queue_conflict_container[check_conflict_result.val2]->get_hash_key();
								to_follow_wall=false;
							}

							breakpt.vals = rq_queue->queue_point_slots.size();
							breakpt.pt = conflict_pt.pt;
							//rq_queue->update_direction(breakpt.pt, align_direc, 1);
							double new_oset;
							new_oset = ssunit - pt_pt_dist(q_info.last_slot, breakpt.pt);
							destination = offsetptrand(breakpt.pt, align_direc, new_oset, 0);

						
								
						}
						else if (flag == 3)
						{
							//PRX_PRINT("gs 8", PRX_TEXT_LIGHTGRAY);
							//PRX_PRINT("wall structure size:", PRX_TEXT_LIGHTGRAY);
							//PRX_PRINT(wall_segment_structures_container.size(), PRX_TEXT_LIGHTGRAY);


							//// // cout<<"following wall analysis______________________________________-"<<endl;
							//// // cout<<"queueid:"<<endl;
							//// // cout<<rq_queue_id<<endl;
							//// // cout<<"last and try"<<endl;
							//// // cout<<seg->startpt.x<<","<<seg->startpt.y<<","<<seg->endpt.x<<","<<seg->endpt.y<<endl;
							//// // cout<<"theta:"<<endl;
							//// // cout<<cart2pol(q_info.latest_direction.x-seg->startpt.x,q_info.latest_direction.y-seg->startpt.y,0)[0]<<endl;
							//// // cout<<"follow buffer walls ending at:"<<endl;
							//// // cout<<rq_queue->following_seg_hash_key<<endl;
							//// // cout<<rq_queue->get_direction().x<<","<<rq_queue->get_direction().y<<endl;
							//// // cout<<"bufferwalls: size:"<<bufferwalls.size()<<endl;
							//// // cout<<endl;
							// for(int l=0;l<bufferwalls.size();l++)
							// {
							// 	// // cout<<bufferwalls[l]->get_hash_key()<<endl;
							// 	// // cout<<bufferwalls[l].startpt.x<<","<<bufferwalls[l].startpt.y<<","<<bufferwalls[l].endpt.x<<","<<bufferwalls[l].endpt.y<<endl;
							// }

							//// // cout<<"walls: size:"<<wall_container_temp.size()<<endl;
							//// // cout<<endl;
							// for(int l=0;l<wall_container_temp.size();l++)
							// {
							// 	// // cout<<wall_container_temp[l]->get_hash_key()<<endl;
							// 	// // cout<<wall_container_temp[l]->startpt.x<<","<<wall_container_temp[l]->startpt.y<<","<<wall_container_temp[l]->endpt.x<<","<<wall_container_temp[l]->endpt.y<<endl;
							// }


							//// // cout<<"following wall analysis______________enddddddd________________________endddddddddd-"<<endl;

							int connect_buffer = -1;
							segment_t* bufferseg;
							int left_right=1;

							for (int i = 0;i <= (wall_segment_structures_container.size())*2-1;i++)
							{
								//if (bufferwalls[i].startpt.equal(rq_queue->get_direction()) || bufferwalls[i].endpt.equal(rq_queue->get_direction()))/ /skip the current aligned buffer wall (already reach end)
								if(wall_segment_structures_container[int(i/2)]->get_hash_key()==rq_queue->following_seg_hash_key-1000 ||wall_segment_structures_container[int(i/2)]->get_hash_key()==rq_queue->following_seg_hash_key-2000)
								{
									//PRX_PRINT("gs 8.0", PRX_TEXT_LIGHTGRAY);
									// continue;
								}
								
								if(i%2==0)
								{
									bufferseg=wall_segment_structures_container[int(i/2)]->buffer_segment_left;
									seg_key=wall_segment_structures_container[int(i/2)]->get_hash_key()+1000;
								}
								else
								{
									bufferseg=wall_segment_structures_container[int(i/2)]->buffer_segment_right;
									seg_key=wall_segment_structures_container[int(i/2)]->get_hash_key()+2000;
								}


								

								int if_conflict_wall = -1;
								int if_conflict_queue = -1;

								points_t target_point; 
								points_t target_direction;
								
								target_point.set(-999,-999,-999);
								if (pt_pt_dist(rq_queue->get_direction(), bufferseg->startpt) < 2 * ssunit - 0.01)// && pt_pt_dist(rq_queue->get_direction(), bufferwalls[i].startpt) > 1e-6)
								{
									target_point = bufferseg->startpt;
									target_direction=bufferseg->endpt;
								}
								else if (pt_pt_dist(rq_queue->get_direction(), bufferseg->endpt) < 2 * ssunit - 0.01)// && pt_pt_dist(rq_queue->get_direction(), bufferwalls[i].endpt) > 1e-6)
								{
									target_point = bufferseg->endpt;
									target_direction = bufferseg->startpt;
								}
								else
								{
									continue;
								}

								if (target_point.x == -999)
									continue;


								if(abs(cart2pol(q_info.latest_direction.x-seg->startpt.x,q_info.latest_direction.y-seg->startpt.y,0)[0]-cart2pol(target_point.x-target_direction.x,target_point.y-target_direction.y,0)[0])<1e-4)
								{
									//PRX_PRINT("gs 8.05", PRX_TEXT_LIGHTGRAY);
									continue;
								}
								segment_t* tmpseg=new segment_t;
								tmpseg->startpt = rq_queue->get_direction();
								tmpseg->endpt = target_point;
								tmpseg->cal_para();
								for (int j = 0;j<wall_segment_structures_container.size();j++) //***change
								{
									if (check_seg_intersec(tmpseg, wall_segment_structures_container[j]->actual_segment).vals == 1)
									{
										if_conflict_wall = j;
										//PRX_PRINT("gs 8.1", PRX_TEXT_LIGHTGRAY);
										break;
									}
									else if (judge_bt_points(tmpseg->endpt, wall_segment_structures_container[j]->actual_segment->startpt, wall_segment_structures_container[j]->actual_segment->endpt) == 2)
									{
										if_conflict_wall = j;
										//PRX_PRINT("gs 8.2", PRX_TEXT_LIGHTGRAY);
										break;
									}
								}

								if (if_conflict_wall == -1) //check whether it cross a queue
								{
									util::hash_t<int, std::vector<segment_struct_t*> >::iterator it;
									it=queue_segment_structures_container.begin();
									while(it!=queue_segment_structures_container.end())
									{
										int j=0;
										foreach(segment_struct_t* segment_structure, it->second)
										{
											if (check_seg_intersec(tmpseg, segment_structure->actual_segment).vals == 1)
											{
												if_conflict_queue = it->first*10000+j;
												//PRX_PRINT("gs 8.3", PRX_TEXT_LIGHTGRAY);
												break;
											}
											else if (judge_bt_points(tmpseg->endpt, segment_structure->actual_segment->startpt, segment_structure->actual_segment->endpt) == 2)
											{
												if_conflict_queue = it->first*10000+j;
												//PRX_PRINT("gs 8.4", PRX_TEXT_LIGHTGRAY);
												break;
											}
											j++;
										}

										it++;
									}


									


									
								}

								if (if_conflict_wall == -1 && if_conflict_queue == -1)//good wall to follow
								{
									//PRX_PRINT("gs 9", PRX_TEXT_LIGHTGRAY);
									//// // cout<<target_point.x<<","<<target_point.y<<endl;
									//// // cout<<target_direction.x<<","<<target_direction.y<<endl;
									//// // cout<<cart2pol(target_direction.x-target_point.x,target_direction.y-target_point.y,0)[0]<<endl;
									//todo
									//destination.pt.set(0.5*(tmpseg->startpt.x+tmpseg->endpt.x),0.5*(tmpseg->startpt.y+tmpseg->endpt.y),0.5*(tmpseg->startpt.z+tmpseg->endpt.z));
									//destination.pt=tmpseg->startpt;

									connect_buffer = i;

									destination.pt = tmpseg->endpt;
									destination.vals = pt_pt_dist(tmpseg->endpt, destination.pt);

									destination.pt=extend_direction(destination.pt,target_direction,(0.5*ssunit)/pt_pt_dist(destination.pt,target_direction));
									//destination.pt=extend_direction(destination.pt,target_direction,(ssunit-pt_pt_dist(destination.pt,last_point))/pt_pt_dist(destination.pt,target_direction));

									to_follow_wall=true;


									breakpt.pt = seg->startpt;
									//breakpt.vals = pt_pt_dist(rq_queue->breakpts.back().pt, seg->startpt);
									breakpt.vals = rq_queue->queue_point_slots.size();

									
									rq_queue->add_breakpts(breakpt);
									breakpt.pt = destination.pt;
									//breakpt.vals = pt_pt_dist(rq_queue->breakpts.back().pt, destination.pt);
									rq_queue->add_breakpts(breakpt);

									//rq_queue->direction_list.push_back(rq_queue->direction);
									rq_queue->update_direction(destination.pt, target_direction, 1);
									rq_queue->following_seg_hash_key=seg_key;
									rq_queue->following_a_wall=to_follow_wall;
									//PRX_PRINT("Queue Manager generate slots Called 99999999 ", PRX_TEXT_LIGHTGRAY);
									rq_queue->add_new_slot(destination);
									break;
								}
								if(tmpseg!=NULL)
								{
									delete tmpseg;
									tmpseg=NULL;
								}
								
							}//for (int i = 0;i < bufferwalls.size();i++)
							
							
							if (connect_buffer == -1) //queue cannot connect another buffer wall
							{
								//PRX_PRINT("gs 10", PRX_TEXT_LIGHTGRAY);
								//rq_queue->direction_list.push_back(rq_queue->direction);
								rq_queue->update_direction(seg->startpt, rq_queue->get_direction(), 500);
								//PRX_PRINT("Queue manager generate_slots 15 #", PRX_TEXT_LIGHTGRAY);
								rq_queue->add_new_slot(destination);
								rq_queue->following_seg_hash_key=-1;
								rq_queue->following_a_wall=false;
								destination = try_point;
								
							}

							if(seg!=NULL)
							{
								delete seg;
								seg=NULL;
							}
							
							if (slot_number != 2)
							{
								return 1;
							}
							else
							{
								return 2;
							}

						}//else if (flag == 3)
						else
						{
							if(seg!=NULL)
							{
								delete seg;
								seg=NULL;
							}
							
							return -2;
						}

						//PRX_PRINT("queue triangle_slots_size:"<<rq_queue->triangle_slots.size(),PRX_TEXT_LIGHTGRAY);
						//below: flag==1 or flag ==2 (when flag==3, the function will be returned in the above "if (flag==3)" section)
						//double check new direction's conflict
						segment_t* seg1=new segment_t;
						seg1->startpt = breakpt.pt;
						seg1->endpt = destination.pt;
						seg1->cal_para();
						_2numnpt conflict_result2;

						conflict_result2 = check_conflict(seg1);
						check_conflict_result = check_conflict(seg);
						int flag2 = conflict_result2.val1;
						if (flag2 == 0 || flag2 == -1) //no conflict with any wall/queue
						{
							////PRX_PRINT("gs 10.5", PRX_TEXT_LIGHTGRAY);
							//below:refined check
							double dist1, dist2;
							int if_close_to_wall = -1;
							segment_t* newseg= new segment_t;
							for (int i = 0;i<wall_segment_structures_container.size();i++)
							{
								dist1 = pt_seg_dist(seg1->endpt, wall_segment_structures_container[i]->actual_segment);
								dist2 = pt_seg_dist(seg1->startpt, wall_segment_structures_container[i]->actual_segment);

								//if(pt_seg_dist(seg1->endpt,wall_container_temp[i]->getwall())<5 && pt_seg_dist(seg1->endpt,wall_container_temp[i]->getwall())<pt_seg_dist(seg1->startpt,wall_container_temp[i]->getwall()))
								if (dist1<sunit && dist1<dist2 && judge_bt_points(pt_seg_intersec_pt(seg1->endpt, wall_segment_structures_container[i]->actual_segment), wall_segment_structures_container[i]->actual_segment->startpt, wall_segment_structures_container[i]->actual_segment->endpt) != 0)
								{
									points_t newpt;
									newpt=extend_direction(seg1->startpt,seg1->endpt,5);
									
									newseg->set(seg1->startpt,newpt);

									if(check_seg_intersec(newseg,wall_segment_structures_container[i]->actual_segment).vals==2)
									{
										if_close_to_wall = i;
										break;
									}									
								}
							}
							if(newseg!=NULL)
							{
								delete newseg;
								newseg=NULL;
							}

							int if_close_to_queue = -1;
							int if_close_to_breakpt = -1;

							util::hash_t<int, std::vector<segment_struct_t*> >::iterator it1;
							it1=queue_segment_structures_container.begin();
							while(it1!=queue_segment_structures_container.end())
							{
								foreach(segment_struct_t* segment_structure, it1->second)
								{
									if (if_close_to_queue == -1)
									{
										
										dist1 = pt_seg_dist(seg1->endpt, segment_structure->actual_segment);
										dist2 = pt_seg_dist(seg1->startpt, segment_structure->actual_segment);
										if (dist1 < 0.85*sunit && dist1 < dist2)
										{

											if(segment_structure->object_id==rq_queue->queue_id && segment_structure->segment_id==rq_queue->breakpts.size() )//- 1)
											{
												if_close_to_queue = -1;

											}
											else if (judge_bt_points(pt_seg_intersec_pt(seg1->endpt, segment_structure->actual_segment), segment_structure->actual_segment->startpt, segment_structure->actual_segment->endpt) != 2)

											{
												if_close_to_queue = -1;

											}
											else
											{

												if_close_to_queue = segment_structure->get_hash_key();
												//continue;
											}
										}
									}

									if (if_close_to_breakpt == -1)
									{
										

										for (int j = 0;j<2;j++)
										{


											if(segment_structure->object_id==rq_queue_id)// && queue_segs_obtained[i]->segment_id==rq_queue->breakpts.size()) // - 1 )
											//if(queue_segs_obtained[i]->object_id==rq_queue_id) 
											{
												break;
											}

											if(j==0)
											{
												dist1 = pt_pt_dist(seg1->endpt, segment_structure->actual_segment->startpt);
												dist2 = pt_pt_dist(seg1->startpt, segment_structure->actual_segment->startpt);
											}
											else
											{
												dist1 = pt_pt_dist(seg1->endpt, segment_structure->actual_segment->endpt);
												dist2 = pt_pt_dist(seg1->startpt, segment_structure->actual_segment->endpt);
											}
											

											if (dist1<0.85*sunit && dist1<dist2)
												//if(pt_pt_dist(seg1->endpt,queue_container[i]->breakpts[j].pt)<5 && pt_pt_dist(seg1->endpt,queue_container[i]->breakpts[j].pt)<pt_pt_dist(seg1->startpt,queue_container[i]->breakpts[j].pt))
											{
												if_close_to_breakpt = segment_structure->get_hash_key();
												//PRX_PRINT("if_close_to_bkpt"<<if_close_to_breakpt, PRX_TEXT_LIGHTGRAY);
												// PRX_PRINT(queue_segs_obtained[i]->get_hash_key(), PRX_TEXT_LIGHTGRAY);
												// PRX_PRINT(rq_queue->breakpts.size(), PRX_TEXT_LIGHTGRAY);
												break;
											}
										}						

									}								

									if (if_close_to_queue != -1 && if_close_to_breakpt != -1)
									{
										//PRX_PRINT("HERE:: if_close_to_bkpt"<<if_close_to_breakpt, PRX_TEXT_LIGHTGRAY);
										it1=queue_segment_structures_container.end();
										break;
									}
								}

								if(it1 == queue_segment_structures_container.end())
									break;

								it1++;
							}

							if(seg1!=NULL)
							{
								delete seg1;
								seg1=NULL;
							}
							

							if (if_close_to_wall == -1 && if_close_to_queue == -1 && if_close_to_breakpt == -1)
							{
								break; //break while (1,2,3), means the try_point pass two times conflict check
							}
							else
							{
								// PRX_PRINT("gs 11", PRX_TEXT_LIGHTGRAY);
								// PRX_PRINT(if_close_to_wall, PRX_TEXT_LIGHTGRAY);
								// PRX_PRINT(if_close_to_queue, PRX_TEXT_LIGHTGRAY);
								// PRX_PRINT(if_close_to_breakpt, PRX_TEXT_LIGHTGRAY);
								iterate_time++;
								turn_angle = 1; //large angle turn
							}
							//above:refined check
						}//if (flag2 == 0 || flag2 == -1)
						else if (flag2 == 1 || flag2 == 2)
						{
							// PRX_PRINT("gs 10.2", PRX_TEXT_LIGHTGRAY);
							// cout<<"flag2:"<<flag2<<endl;
							iterate_time++;
							turn_angle = 1; //large angle turn		
						}

						//above: flag==1 or flag ==2 (when flag==3, the function will be returned in the above "if (flag==3)" section)
						//double check new direction's conflict

					}//while (flag == 1 || flag == 2 || flag == 3)

					//below:flag=1 or 2, and pass 2 times conflict check
					breakpt.vals = rq_queue->queue_point_slots.size();
					rq_queue->add_breakpts(breakpt);
					if (flag == 1)
					{
						//rq_queue->direction_list.push_back(rq_queue->direction);
						rq_queue->update_direction(breakpt.pt, align_direc, 1);
						rq_queue->following_seg_hash_key=seg_key;
						rq_queue->following_a_wall=to_follow_wall;
					}
					else
					{
						//rq_queue->direction_list.push_back(rq_queue->direction);
						rq_queue->update_direction(breakpt.pt, align_direc, 500);
						rq_queue->following_seg_hash_key=seg_key;
						rq_queue->following_a_wall=to_follow_wall;
					}
					//PRX_PRINT("gs 12", PRX_TEXT_LIGHTGRAY);
					// cout<<"direction"<<endl;
					// cout<<rq_queue->direction.x<<","<<rq_queue->direction.y<<endl;
					// cout<<"destination"<<endl;
					// cout<<destination.pt.x<<","<<destination.pt.y<<endl;
					//above
				}
				else //flag error
				{
					if(seg!=NULL)
					{
						delete seg;
						seg=NULL;
					}
					
					return -3;
				}

				if(seg!=NULL)
				{
					delete seg;
					seg=NULL;
				}
				

				if (slot_number != 2)
				{
					rq_queue->add_new_slot(destination);
					return 1;
				}
				else
				{
					rq_queue->add_new_slot(destination);
					return 2;
				}


				return 0;
			}

			void queue_managers_t::get_environment_from_triangle_structure(int index,queue_t* rq_queue,int dist)
			{
				
				rq_queue->nearby_queue_info(wall_segment_structures_container, queue_segment_structures_container, dist); 
				// cout<<"get environment succesfully"<<endl;
				// cout<<wall_segment_structures_container.size()<<","<<queue_segment_structures_container.size()<<endl;
				// queue_seg_it=queue_segment_structures_container.begin();
				return;

			}

			void queue_managers_t::get_environment_from_triangle(int index,queue_t* rq_queue,int dist)
			{
				// wall_container_temp.clear();
				// queue_segs_obtained.clear();
				// bufferwalls.clear();
				// bufferqueues.clear();


    //             deque<segment_struct_t*> wall_segment_structures;
	   //          util::hash_t<int, std::vector<segment_struct_t*> > queue_segment_structures;



   	// 			//rq_queue->nearby_queue_info(w, bw, q, bq, dist);

    //             rq_queue->nearby_queue_info(wall_segment_structures, queue_segment_structures, dist);             
    	 		
    	 		
				// for (int i=0;i<wall_segment_structures.size();i++)
    //             {
                
    //         		wall_container_temp.push_back(wall_segment_structures[i]->actual_segment);
            		

    //             	bufferwalls.push_back(wall_segment_structures[i]->buffer_segment_left);
    //             	bufferwalls.push_back(wall_segment_structures[i]->buffer_segment_right);

                	
    //             }


    //             util::hash_t<int, std::vector<segment_struct_t*> >::iterator it;
    //             it=queue_segment_structures.begin();
    //             unsigned i=0;
    //             while(it!=queue_segment_structures.end())
    //             {
                	
    //             	foreach(segment_struct_t* segment_structure, it->second)
    //             	{
                		
	   //              	queue_segs_obtained.push_back(segment_structure->actual_segment);
	   //          		segment_structure->actual_segment->object_id=segment_structure->object_id;
	   //          		segment_structure->actual_segment->segment_id=segment_structure->segment_id;
	            		
	   //              	bufferqueues.push_back(segment_structure->buffer_segment_left);

	   //              	bufferqueues.push_back(segment_structure->buffer_segment_right);
    //             	}            	
    //             	it++;i++;
    //             }



    //             if(1)
    //             {
    //             	// cout<<"____________________-environment information analysis_____________________________"<<endl;
    //             	// cout<<rq_queue->queue_id<<" sizes:"<<endl;
    //             	// cout<<wall_container_temp.size()<<","<<bufferwalls.size()<<","<<queue_segs_obtained.size()<<","<<bufferqueues.size()<<endl;
    //             	//// cout<<w.size()<<","<<bw.size()<<","<<q.size()<<","<<bq.size()<<endl;
    //             	// cout<<endl<<"***********"<<"wall"<<endl;
    //             	for(int i=0;i<wall_container_temp.size();i++)
    //             	{
    //             		// cout<<wall_container_temp[i]->get_hash_key()<<endl;
    //             		// cout<<wall_container_temp[i]->startpt.x<<","<<wall_container_temp[i]->startpt.y<<","<<wall_container_temp[i]->endpt.x<<","<<wall_container_temp[i]->endpt.y<<endl;
    //             	}
    //             	// cout<<endl<<"***********"<<"bufferwalls"<<endl;
    //             	for(int i=0;i<bufferwalls.size();i++)
    //             	{
    //             		// cout<<bufferwalls[i]->get_hash_key()<<endl;
    //             		// cout<<bufferwalls[i]->startpt.x<<","<<bufferwalls[i]->startpt.y<<","<<bufferwalls[i]->endpt.x<<","<<bufferwalls[i]->endpt.y<<endl;
    //             	}
    //             	// cout<<endl<<"***********"<<"queues"<<endl;
    //             	for(int i=0;i<queue_segs_obtained.size();i++)
    //             	{
    //             		// cout<<queue_segs_obtained[i]->get_hash_key()<<endl;
    //             		// cout<<queue_segs_obtained[i]->startpt.x<<","<<queue_segs_obtained[i]->startpt.y<<","<<queue_segs_obtained[i]->endpt.x<<","<<queue_segs_obtained[i]->endpt.y<<endl;
    //             	}




    //             	// cout<<endl<<"***********"<<"bufferqueues"<<endl;
    //             	for(int i=0;i<bufferqueues.size();i++)
    //             	{
    //             		// cout<<bufferqueues[i]->get_hash_key()<<endl;
    //             		// cout<<bufferqueues[i]->startpt.x<<","<<bufferqueues[i]->startpt.y<<","<<bufferqueues[i]->endpt.x<<","<<bufferqueues[i]->endpt.y<<endl;
    //             	}
    //             	// cout<<"end____________________-environment information analysis_____________________________end"<<endl;
    //             }
				return;

               
			}

			


			void queue_managers_t::get_environment_for_update_start_point(const nav_node_t* nav_node,queue_t* rq_queue,int dist)

			{



				rq_queue->nearby_queue_info_at_node(const_cast<nav_node_t*>(nav_node), wall_segment_structures_container, queue_segment_structures_container, dist);
				//queue_seg_it=queue_segment_structures_container.begin();
				return;
    //             deque<segment_struct_t*> wall_segment_structures;
	   //          util::hash_t<int, std::vector<segment_struct_t*> > queue_segment_structures;
    //             rq_queue->nearby_queue_info_at_node(const_cast<nav_node_t*>(nav_node), wall_segment_structures, queue_segment_structures, dist);             
    	 		
    // 	 		segment_t tmpseg;
				// for (int i=0;i<wall_segment_structures.size();i++)
    //             {
                	
    //             	wall_container_temp.push_back(wall_segment_structures[i]->actual_segment);


                	
    //             	bufferwalls.push_back(wall_segment_structures[i]->buffer_segment_left);

                
    //             	bufferwalls.push_back(wall_segment_structures[i]->buffer_segment_right);
    //             }



    //             util::hash_t<int, std::vector<segment_struct_t*> >::iterator it;
    //             it=queue_segment_structures.begin();
    //             while(it!=queue_segment_structures.end())
    //             {
    //             	foreach(segment_struct_t* segment_structure, it->second)
    //             	{
                		
	   //              	queue_segs_obtained.push_back(segment_structure->actual_segment);
	            		
	            		
	   //              	bufferqueues.push_back(segment_structure->buffer_segment_left);

	            		
	   //              	bufferqueues.push_back(segment_structure->buffer_segment_right);
    //             	}            	
    //             	it++;
    //             }
                return;
			}

			bool queue_managers_t::update_start_point(points_t& start_point, const nav_node_t* first_nav_node,queue_t* rq_queue)
			{
				//update the first point and store it back to ini_pt. If you had to do any change then return true. Otherwise, false.
				//Use the first_nav_node->nearby_queue_info()
				_numnpt try_point;
				try_point.vals = 0;
				try_point.pt = start_point;

				double dist = 999;
				segment_t* wallseg;

				//rq_queue->get_nearby_queue_info_node(first_nav_node, walls, walls_buf, etc etc)

				get_environment_for_update_start_point(first_nav_node,rq_queue,3);

				bool ret=false;
				
				for (int i = 0;i<wall_segment_structures_container.size();i++)
				{
					wallseg = wall_segment_structures_container[i]->actual_segment;
					wallseg->cal_para();
					dist = pt_seg_dist(try_point.pt, wallseg);
					if (dist<sunit)
					{
						points_t intersec_pt = pt_seg_intersec_pt(try_point.pt, wallseg);

						if (judge_bt_points(intersec_pt, wallseg->startpt, wallseg->endpt) == 2)
						{
							try_point.pt = intersec_pt;
							ret=true;
						}

					}
				}
				start_point=try_point.pt;
				rq_queue->add_queue_point_slot(try_point);
				rq_queue->breakpts.front().pt = try_point.pt;
				
				
				
				return ret;		
			}

			// Adds the given queue to the list of queues
			void queue_managers_t::insert_queue(queue_t* queue){
				queues_list.push_back(queue);
			}

			// Get a pointer to the list of queues
			deque<queue_t*>& queue_managers_t:: get_queues(){
				return queues_list;
			}

        }
    }
}
