/**
 * @file queue.hpp
 *
 * @copyright Software License Agreement (BSD License)
 * Copyright (c) 2013, Rutgers the State University of New Jersey, New Brunswick
 * All Rights Reserved.
 * For a full description see the file named LICENSE.
 *
 * Authors: Andrew Dobson, Andrew Kimmel, Athanasios Krontiris, Zakary Littlefield, Kostas Bekris
 *
 * Email: pracsys@googlegroups.com
 */

#pragma once

#ifndef PRX_AGENT_QUEUE_HPP
#define PRX_AGENT_QUEUE_HPP

#include "simulation/structures/agent_data.hpp"
#include "simulation/structures/queue_struct.hpp"
//#include "simulation/structures/queue_manager.hpp"

#define XY_DISTANCE_CHECK  5e-1

namespace prx 
{
    namespace packages
    {
        namespace crowd
        {
    	    typedef std::pair< std::vector< double >, std::vector< double > > wall_t_vec;
    	    class queue_managers_t;
            class behavior_controller_t;
		    class _queue_info
		    {
			    public:
			    //	deque<int> ageng_id;
				int queue_id;
				string queue_name;
			    //	deque<points_t> agent_loc;
				points_t latest_direction;
				points_t last_position;
				points_t start_point;
				points_t last_slot;
				double floor_level;
				double queue_length;
			    //	deque<_numnpt> break_pts;
		    };

	//////////////////////////////////


		    struct _agent_list_item{int agent_id;behavior_controller_t* agent_pter;points_t location_pt;};


		    //agents[0]->plant->get_current_position(vector<double> current_pos);

		    class queue_t
		    {
		      public:
		        //constructor
		        queue_t();

		        // constructor with id
		        queue_t(int queue_id);

				// Intialize queue for region
				//queue_t(int queue_id, string& queue_name, double fluctuation_angle, double first_turn_dist,double floor_level, points_t q_start_point);
		        virtual ~queue_t();

		        //Agent addition and removal                
		        void pop_first_agent();  //pop the first agent in the queue, the following agents will automatically move one step ahead(occupy his preceding agent)		        

		        // Is invoked by the region when it is time for departure - Force min(queue length, amount) to leave the queue
		       	void depart_agents(int amount);

		      	void update_direction(points_t refpt,points_t new_direc,double times); //change the direction of this queue. refpt is a break point, new_direc is a direction point(will automatically extend to a further point,or extend to an end of wall)

		        //queue initial
				//void initial_queue(points_t ini_statp, points_t ini_direc, double ft_dist, double ft_angle);//emperical line which is input from UI //not using this in linux
		        void init(points_t ini_pt, string& name, double  angle, double fluctuation, double floor_level, double ft_dist,double ft_angle, double spacing); //in interface

		        //get information
		        points_t get_last_position_pt();//get the last agent's location

				points_t get_last_slot_pt(); //get last available slot

		        vector<double> get_last_position_vector();
		        
		        _queue_info get_queue_info(); //get a bunch of queue information
		        
		        points_t get_direction();
				
				double queue_size();

				// Aditya's Code start

				// Function to add the start triangle details into the queue
				void add_start_triangle(points_t start_point, nav_node_t* nav_node);

				// Given the destination point generated by queue manager 
				// Add the corresponding triangle node to the queue and to the queue point slot
				void add_new_slot(_numnpt destination_point);

				//add an agent into the queue				

				// Add navigation node corresponding to the traingle.
				void add_triangle_slot(const nav_node_t* nav_node);

				void add_queue_point_slot(_numnpt destination_point);

				void add_breakpts(_numnpt destination_point);				
				
				// Get the list of triangle slots
				deque<const nav_node_t*>& get_triangle_slots();

				// Gets an open slot for the calling pfc
				const nav_node_t* get_open_slot(behavior_controller_t* agent);

				// Reserves a slot for the calling pfc and sets the x,y,z cordinates of the slot 
				const nav_node_t* reserve_slot(behavior_controller_t* agent,std::vector<double>& queue_points, int frames_to_leave, double &orientation);

				// Check if the agent is the first one in queue
				bool is_first_agent(std::vector<double>& current_position, behavior_controller_t* agent);

				// Move agents in queue according to their frames_to_leave
     	    	unsigned put_agent_in_queue(behavior_controller_t* agent, int frames_to_leave);

				// Set the doubles required for the reserved slot (queue point)
				// void set_reserve_slot_point(std::vector<double>& queue_points);

				unsigned get_available_slot_index();
				
				void reset_available_slot_index();

				// Given the previous triangle node and the current state find the corresponding triangle for the current state
				nav_node_t* find_triangle_from_previous_slot( const nav_node_t* prev_nav_node, const std::vector< double >& current_state );
				// End
				//provided by andrew
		        // const std::vector< wall_t_vec >& get_walls_at_back();
		        // const std::vector< wall_t_vec >& get_walls_at_index( unsigned index );

				// Fill segment and buffer information
     	    	//void fill_segment_and_buffer_line_info(points_t start_point, points_t end_point, segment_t*& segment, segment_t*& segment_buffer_line_left, segment_t*& segment_buffer_line_right);
     	    	void fill_segment_structure_info(points_t start_point, points_t end_point, segment_struct_t*& segment_structure);

            	void update_segment(segment_t& segment, points_t end_pt);

	            //Returns the information that is needed from the Queue Manager. This information is computed from the last slot of the queue. 
				void nearby_queue_info(std::deque<segment_struct_t*>& arg_wall_segment_structures,util::hash_t<int, std::vector<segment_struct_t*> >& arg_queue_segment_structures, int search_depth=3);

				void nearby_queue_info_at_node(nav_node_t* nav_node, std::deque<segment_struct_t*>& arg_wall_segment_structures, util::hash_t<int, std::vector<segment_struct_t*> >& arg_queue_segment_structures, int search_depth=3);

				/**
				 * @brief [brief description]
				 * @details .... The queue_point_slots list will be changed and we have to update the new points. 
				 * 
				 * @param start_index [description]
				 * @param end_index [description]
				 */
				void reform_queue(int start_index, int end_index);

		        int queue_id;
		        string queue_name;
				string queue_destination;
				double angle;
		        double floor_level;
		        
				points_t direction;
				points_t q_start_point;

		        deque<_numnpt> breakpts; //break points are the points where the queue changed its direction(e.g. encounter a wall) //val=after agent_list[val] agent, the breakpoint is set
				double fluctuation_angle;

				double spacing;
				points_t first_turn; 
				points_t first_turn_direction;
				double first_turn_dist;
				double first_turn_angle;
				bool reach_first_turn;

				bool if_trapped;
				int following_seg_hash_key;
				bool following_a_wall;

		        deque<double> net_distance; 

				unsigned available_slot_index;

				deque<_numnpt> queue_point_slots; // // List of Queue points
				
				deque<const nav_node_t*> triangle_slots;
				deque<segment_struct_t*> queue_segment_structures;

				std::vector< double > cur_queue_state;
				
				const nav_node_t* prev_nav_node; 
				const nav_node_t* cur_nav_node;
	            const nav_node_t* neighbor;
				/// End

				deque<points_t> direction_list;

				deque< behavior_controller_t* > agents_in_queue;
				queue_managers_t* queue_manager;

				static int global_neighbor_search_id;	  
		
		    };

		    extern deque<queue_t*> queue_container;//all created queues' pointer will be stored in this container automatically
        }
    }
}

#endif //PRX_AGENT_QUEUE_HPP
